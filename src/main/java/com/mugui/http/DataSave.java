/*** Eclipse Class Decompiler plugin, copyright (c) 2016 Chen Chao (cnfree2000@hotmail.com) ***/package com.mugui.http;import com.mugui.http.Bean.UserBean;import com.mugui.http.pack.UdpBag;import com.mugui.http.tcp.TcpSocketUserBean;import net.sf.json.JSONObject;import java.util.Iterator;import java.util.Map.Entry;import java.util.concurrent.ConcurrentHashMap;public class DataSave {	private static ConcurrentHashMap<String, UserThread> checkMap = new ConcurrentHashMap<String, UserThread>();	private static UserThread getUdpSocket(String user_id) {		UserThread userThread = checkMap.get(user_id);		if (userThread == null || !userThread.isAlive())			return null;		return userThread;	}	public static UdpBag getUDPSocket(String user_id) {		UserThread userThread = getUdpSocket(user_id);		if (userThread == null || !userThread.isAlive())			return null;		return userThread.getUdpSocket();	}	public static void reUDPSocket(String user_id) {		UserThread userThread = getUdpSocket(user_id);		if (userThread == null)			return;		userThread.setTime(UserThread.INIT_TIME);	}	public static void addUDPSocket(String user_id, UdpBag tcpSocket) {		UserThread u = checkMap.get(user_id);		if ((u != null) && (u.isAlive())) {			u.setUdpSocket(tcpSocket);		} else {			u = new UserThread();			u.setTime(UserThread.INIT_TIME);			u.start();			u.setUdpSocket(tcpSocket);			checkMap.put(user_id, u);		}	}	public static void delUDPSocket(String user_mail) {		UserThread thread = checkMap.remove(user_mail);		if (thread != null)			thread.setTime(-1);	}	public static void updataUDPSocket(String user_mail, UdpBag writer) {		UserThread userThread = getUdpSocket(user_mail);		userThread.setUdpSocket(writer);		userThread.setTime(600000);	}	public static void delSocketAll() {		Iterator<Entry<String, UserThread>> it = checkMap.entrySet().iterator();		while (it.hasNext()) {			it.next().getValue().setTime(-1);			it.remove();		}	}	public static String getUDPCheck(String user_mail) {		UdpBag u = getUDPSocket(user_mail);		if (u == null)			return null;		UserBean bean = new UserBean(JSONObject.fromObject(u.getBody()));		return bean.getUser_mac();	}	public static void removeUdpCheck(String user_mail) {		UdpBag u = getUDPSocket(user_mail);		if (u == null)			return;		UserBean bean = new UserBean(JSONObject.fromObject(u.getBody()));		bean.setUser_mac(null);	}	// 建立一个用户登录之后的表	private static ConcurrentHashMap<String, TcpSocketUserBean> hashMap = new ConcurrentHashMap<String, TcpSocketUserBean>();	// 通过标记得到一个用户的TcpSocketUserBean	public static TcpSocketUserBean getTcpSocket(String user_mail) {		TcpSocketUserBean userBean = hashMap.get(user_mail);		if (userBean == null || !userBean.isSocketRun())			return null;		return userBean;	}	public static TcpSocketUserBean getAppTcpSocket(String user_mail) {		TcpSocketUserBean userBean = hashMap.get("APP_1.00" + user_mail);		if (userBean == null || !userBean.isSocketRun())			return null;		return userBean;	}	public static void addAppTcpSocket(String user_mail, TcpSocketUserBean tcpSocket) {		hashMap.put("APP_1.00" + user_mail, tcpSocket);	}	public static Iterator<String> getUserAll() {		Iterator<Entry<String, TcpSocketUserBean>> iterator = hashMap.entrySet().iterator();		while (iterator.hasNext()) {			if (!iterator.next().getValue().isSocketRun()) {				iterator.remove();			}		}		return hashMap.keySet().iterator();	}	public static void addTcpSocket(String string, TcpSocketUserBean tcpSocket) {		hashMap.put(string, tcpSocket);	}	// public static String getCheck(TcpSocketUserBean writer) {	// return (String) writer.getUserData("code");	// }	//	// public static String remove(TcpSocketUserBean writer) {	// return (String) writer.delUserData("code");	// }	public static String getTcpUserMail(TcpSocketUserBean tcpSocket) {		Iterator<Entry<String, TcpSocketUserBean>> iterator = hashMap.entrySet().iterator();		while (iterator.hasNext()) {			Entry<String, TcpSocketUserBean> entry = iterator.next();			if (entry.getValue() == tcpSocket) {				return entry.getKey();			}		}		return "NULL";	}}